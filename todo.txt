Fix gnuplot script on all platforms.
Add the following to the website:

Basic Usage

1. Include the Header File
#include <quickprof/quickprof.h>

2. Initialize the Profiler
This must be called first.  (If this is never called, the profiler is effectively disabled.)  The arguments are: data output filename (implicitly enables data output if this string is not empty), and the second parameter sets the timing method used when saving data to a file.

// Example 1: Initializes the profiler without enabling data file output.
Profiler::init();

// Example 2: Enables data file output using the BLOCK_CYCLE_PERCENT 
// method, which measures the percent of time spent in each cycle for 
// each timed block.
Profiler::init("runtime_performance.dat", Profiler::BLOCK_CYCLE_PERCENT);

3. Setting up Profiling Blocks
Each section of code that is to be profiled must be surrounded with a pair of profiler begin/end calls.  These "profiling blocks" are distinguished by unique name strings.  Note that profiling blocks can overlap or be nested within other blocks if desired.

void mainLoop()
{
	while(true)
	{
		Profiler::beginBlock("input");
		queryUserInput();
		Profiler::endBlock("input");

		Profiler::beginBlock("physics");
		processPhysics();
		Profiler::endBlock("physics");

		Profiler::beginBlock("graphics");
		updateGraphics();
		Profiler::endBlock("graphics");
	}
}

4. Computing Results
There are two main ways to use the profiler.  In each method the block timing information can be returned in various forms, including duration (in microseconds, milliseconds, seconds) or as a percentage of the total elapsed time.

Method 1: Overall Timing Summary
This method simply tracks the total amount of time spent in each block.  When using this method, it is most useful to query the results only once at the end of the program.  Note that the results will become more accurate with longer profiling runs.

TODO: show example code

Method 2: Detailed Timing Summary
This method computes the time spent in each block over the course of a program's execution.  Printing and graphing this data is more informative than simply getting an overall timing summary (as in Method 1).  A "profiling cycle" is defined using calls to 'endProfilingCycle.'  This function must be called regularly (e.g., at the end of each frame in an interactive 3D application).  Since 'endProfilingCycle' updates the latest cycle timing data, it is best to query per-cycle timing data (e.g, the BLOCK_CYCLE_PERCENT timing method) immediately after 'endProfilingCycle.'  In general, this method is useful for printing/graphing timing information over the course of a program's execution.

TODO: show example code

Notes

* Try not to run other applications while profiling your code.  QuickProf simply measures the wall clock time elapsed in each block of code, so any background processes might skew your timing results.
